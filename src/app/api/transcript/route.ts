
import { NextRequest, NextResponse } from 'next/server';

export const maxDuration = 60; // Allow 60 seconds for execution

// List of public Piped API instances to try in order
const PIPED_INSTANCES = [
    'https://pipedapi.kavin.rocks',
    'https://api.piped.privacy.com.de',
    'https://pipedapi.tokhmi.xyz',
    'https://api.piped.otbea.org',
    'https://pipedapi.aeong.one'
];

async function fetchWithTimeout(url: string, options: any = {}, timeout = 10000) {
    const controller = new AbortController();
    const id = setTimeout(() => controller.abort(), timeout);
    try {
        const response = await fetch(url, {
            ...options,
            signal: controller.signal
        });
        clearTimeout(id);
        return response;
    } catch (err) {
        clearTimeout(id);
        throw err;
    }
}

// Convert VTT time (00:00:05.000) to seconds (float)
function vttTimeToSeconds(vttTime: string): number {
    if (!vttTime) return 0;
    const parts = vttTime.split(':');
    let seconds = 0;
    if (parts.length === 3) {
        // HH:MM:SS.mmm
        seconds += parseInt(parts[0]) * 3600;
        seconds += parseInt(parts[1]) * 60;
        seconds += parseFloat(parts[2]);
    } else if (parts.length === 2) {
        // MM:SS.mmm
        seconds += parseInt(parts[0]) * 60;
        seconds += parseFloat(parts[1]);
    }
    return seconds;
}

export async function POST(req: NextRequest) {
    try {
        const body = await req.json();
        const { url, lang } = body;
        console.log(`[Transcript] Piped Request for URL: ${url}, Lang: ${lang}`);

        if (!url) return NextResponse.json({ error: "Missing URL" }, { status: 400 });

        const videoIdMatch = url.match(/(?:v=|youtu\.be\/|\/embed\/|\/v\/)([a-zA-Z0-9_-]{11})/);
        const videoId = videoIdMatch ? videoIdMatch[1] : null;

        if (!videoId) return NextResponse.json({ error: "Invalid YouTube URL" }, { status: 400 });

        let transcriptData = null;
        let availableLanguages = [];
        let errorLog = [];

        // Rotate through Piped instances
        for (const instance of PIPED_INSTANCES) {
            try {
                console.log(`[Transcript] Trying Piped Instance: ${instance}`);
                const streamUrl = `${instance}/streams/${videoId}`;
                const res = await fetchWithTimeout(streamUrl, {}, 8000); // 8s timeout per instance

                if (!res.ok) {
                    errorLog.push(`${instance} returned ${res.status}`);
                    continue;
                }

                const data = await res.json();
                const subtitles = data.subtitles || [];

                if (subtitles.length === 0) {
                    errorLog.push(`${instance} returned no subtitles`);
                    continue; // Try next instance? Maybe specific to instance caching.
                }

                // Prepare available languages list
                availableLanguages = subtitles.map((sub: any) => ({
                    code: sub.code,
                    name: sub.name,
                    is_generated: sub.autoGenerated,
                    url: sub.url
                }));

                // Select best subtitle
                const targetLang = lang || 'en';
                let selectedSub = subtitles.find((s: any) => s.code === targetLang && !s.autoGenerated);
                if (!selectedSub) selectedSub = subtitles.find((s: any) => s.code === targetLang); // Try autogen same lang
                if (!selectedSub) selectedSub = subtitles.find((s: any) => s.code === 'en'); // Fallback to English
                if (!selectedSub) selectedSub = subtitles[0]; // Fallback to first

                if (selectedSub) {
                    console.log(`[Transcript] Found subtitle: ${selectedSub.name} (${selectedSub.code})`);

                    // Fetch the VTT content
                    const vttResponse = await fetchWithTimeout(selectedSub.url);
                    const vttText = await vttResponse.text();

                    // Parse VTT
                    const items = [];
                    // Robust VTT regex
                    const vttRegex = /(?:(\d{2}:)?\d{2}:\d{2}\.\d{3})\s-->\s(?:(\d{2}:)?\d{2}:\d{2}\.\d{3}).*?\n([\s\S]*?)(?=\n\n|\n\d|$)/g;
                    const timeRegex = /((?:\d{2}:)?\d{2}:\d{2}\.\d{3})\s-->\s((?:\d{2}:)?\d{2}:\d{2}\.\d{3})/;

                    // Initial split by double newline to handle cues roughly
                    const cues = vttText.split(/\n\n/);

                    for (const cue of cues) {
                        const timeMatch = timeRegex.exec(cue);
                        if (timeMatch) {
                            const start = vttTimeToSeconds(timeMatch[1]);
                            const end = vttTimeToSeconds(timeMatch[2]);
                            // Clean text: remove timestamps, remove tags like <c.colorE5E5E5>, remove header lines
                            let textRaw = cue.replace(timeRegex, '').replace(/WEBVTT.*/, '').replace(/^\d+$/, '').trim();
                            // Remove tags
                            const text = textRaw.replace(/<[^>]*>/g, '').replace(/\n/g, ' ').trim();

                            if (text) {
                                items.push({
                                    text: text,
                                    offset: { seconds: start },
                                    duration: { seconds: end - start }
                                });
                            }
                        }
                    }

                    // Check results
                    if (items.length > 0) {
                        transcriptData = items;
                        break; // Success! Stop loop.
                    }
                }
            } catch (instErr: any) {
                console.error(`[Transcript] Error with ${instance}:`, instErr.message);
                errorLog.push(`${instance} error: ${instErr.message}`);
            }
        }

        if (!transcriptData) {
            return NextResponse.json({
                error: "No transcript found. All Piped instances failed.",
                debug_log: errorLog
            }, { status: 404 });
        }

        // Return standardized format
        return NextResponse.json({
            success: true,
            video_id: videoId,
            language_code: lang || "en",
            transcript: transcriptData.map(item => ({
                text: item.text,
                start: item.offset.seconds,
                duration: item.duration.seconds
            })),
            available_languages: availableLanguages
        });

    } catch (e: any) {
        return NextResponse.json({ error: "Server Error: " + e.message }, { status: 500 });
    }
}
